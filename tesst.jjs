var t = "jooby"
@t += "y"
var g = (v + 1 for v in [0, 1, 2])
var l = [v - 1 for v in g]
var l2 = [v - 1 for v in g]
@g = (v + 1 for v in [0, 1, 2])
var d = {v - 1: v + 1 for v in g}
var d2 = {k + 1: v - 1 for k, v in d}
@g = (v + 1 for v in [0, 1, 2])
var s = {v - 1 for v in g}
var s2 = {v + 1 for v in s}
@s = {c + c for c in "jooby"}

var a: int = 1
var b = [1, 2]
var c = {1, 2}
@a = b.size >= 1 ? 2 : 1

function fn(b: int): int {
	return a + b
}

function yielder(b: int): int {
	++b
	yield a + b
	@b += 2
	yield a + b
}
@l = [v - 1 for v in yielder(1)]
do {
	if var b = 1, a > 1 {
		@b = fn(b)
		break
	} else if var b = 1, a == 1 {
		continue
	} else if a < 1 {
		@a += 1
	} else {
		var b: dict = {}
	}
} while a < 1
for var a = 1, var b = 1, --a, @fn(a); @fn(a), a < 1; ++a, @fn(a) {
	@b -= fn(b)
}
for ;; {
	switch var b = 1, a - 1 {
		// Although "case" statements have no braces, they create contexts.
		case 1:
			@a = 1
			break

			function fn(b: int): int {
				return a + b
			}
		case 0:
			@a = 3
			break, continue

			function fn(b: int): int {
				return a + b
			}
		default:
			@a = 2
			break, break

			function fn(b: int): int {
				return a + b
			}
	}
}
for var a = 0;; ++a {
	for ; a < 2; {
		if a == 0 {
			break, continue
		} else if a == 1 {
			break, break
		}
	}
}
while var b = 1, a < 3 {
	@a += b
}
@a.b /= b.a
@d[a - 1] *= b[a - 2]
@print(fn(2), b, d, s, t)
