var a: int = 1
var b = [1, 2]
var c = {1, 2}
var d = {1: 2, 2: 1}
@a = b.size >= 1 ? 2 : 1

function fn(b: int): int {
	return a + b
}

do {
	if var b = 1, a > 1 {
		@b = fn(b)
		break
	} else if var b = 1, a == 1 {
		continue
	} else if a < 1 {
		@a += 1
	} else {
		var b: dict = {}
	}
} while a < 1
for var a = 1, var b = 1, --a, @fn(a); @fn(a), a < 1; --a, @fn(a) {
	@b -= fn(b)
}
for ;; {
	switch var b = 1, a - 1 {
		// Although "case" statements have no braces, they create contexts.
		case 1:
			@a = 2
			break

			function fn(b: int): int {
				return a + b
			}
		case 0:
			@a = 3
			break, continue

			function fn(b: int): int {
				return a + b
			}
		default:
			@a = 2
			break, break

			function fn(b: int): int {
				return a + b
			}
	}
}
while var a = 1, a == 1 {
	++a
}
@a.b /= b.a
@a[b] *= b[a]
@print(fn(2))
